# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
# Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
FindVariableFeatures
UseMethod(generic = "FindVariableFeatures", object = object)
showMethods(FindVariableFeatures)
dumpMethod(FindVariableFeatures)
methods(FindVariableFeatures)
FindVariableFeatures.default*
b
FindVariableFeatures.default
FindVariableFeatures.Seurat
?methods
methods(FindVariableFeatures,class = "Seurat")
methods(summary)
summary.irlba_prcomp
plot.default
FindVariableFeatures
UseMethod(generic = "FindVariableFeatures", object = pbmc)
getAnywhere(FindVariableFeatures)
methods(FindVariableFeatures)
getAnywhere(FindVariableFeatures.Seurat)
methods(FindVariableFeatures)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)
# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
getAnywhere(FindVariableFeatures.Seurat)
FindVariableFeatures.Assay
getAnywhere(FindVariableFeatures.Assay)
getAnywhere(FindVariableFeatures.default)
getAnywhere(FindVariableFeatures.default)
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes,vars.to.regress = "percent.mt")
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
# Examine and visualize PCA results a few different ways
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
DimPlot(pbmc, reduction = "pca")
DimPlot(pbmc, reduction = "pca")
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
?DimHeatmap
### 	Plot an equal number of genes with both + and - scores.
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
### 	Plot an equal number of genes with both + and - scores.
mypal <- rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdBu"))(256))
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)+scale_fill_gradientn(colors  = mypal)
### 	Plot an equal number of genes with both + and - scores.
mypal <- rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdBu"))(256))
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE,fast = F)+scale_fill_gradientn(colors  = mypal)
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
ElbowPlot(pbmc)
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
getAnywhere(FindNeighbors)
methods(FindNeighbors)
getAnywhere(FindNeighbors.Seurat)
?FindNeighbors
reticulate::py_install(packages = 'umap-learn')
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages =
# 'umap-learn')
pbmc <- RunUMAP(pbmc,umap.method = "umap-learn", dims = 1:10)
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap")
names(pbmc)
test <- pbmc[["RNA_snn"]]
test <- pbmc[["RNA_nn"]]
test <- pbmc[["RNA_snn"]]
head(test[[2]])
net <- graph.adjacency(adjmatrix = as.matrix(x = test),
mode = "undirected", weighted = TRUE,
diag = FALSE)
library(igraph)
net <- graph.adjacency(adjmatrix = as.matrix(x = test),
mode = "undirected", weighted = TRUE,
diag = FALSE)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["umap"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["umap"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
?DimPlot
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc,label = T, reduction = "umap")
pbmc <- RunTSNE(pbmc,dims = 1:10)
DimPlot(pbmc,label = T, reduction = "tsne")
names(pbmc)
test <- pbmc[["RNA_snn"]]
net <- graph.adjacency(adjmatrix = as.matrix(x = test),
mode = "undirected", weighted = TRUE,
diag = FALSE)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["tsne"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["tsne"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
library(tidyverse)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))
# you can plot raw counts as well
VlnPlot(pbmc, features = c("NKG7", "PF4"), slot = "counts", log = TRUE)
# you can plot raw counts as well
VlnPlot(pbmc, features = c("MS4A1", "CD79A"), slot = "counts", log = TRUE)
?CellScatter
CellScatter(object = pbmc_small, cell1 = 'ATAGGAGAAACAGA', cell2 = 'CATCAGGATGCACA')
FeatureScatter(object = pbmc,feature1 = "MS4A1",feature2 = "CD79A")
FeatureScatter(object = pbmc,feature1 = "MS4A1",feature2 = "CD79A")
FeatureScatter
Seurat:::SingleCorPlot
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A",smooth = T)+
ggtitle(label = NULL)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
"CD8A"))
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
"CD8A"))
top20 <- pbmc.markers %>%
group_by(cluster) %>% top_n(n = 20, wt = avg_logFC)
DoHeatmap(pbmc, features = top20$gene) + NoLegend()+
scale_fill_gradientn(colors  = mypal)
1+1
library(Seurat)
library(SeuratData)
library(ggplot2)
library(igraph)
library(tidyverse)
library(patchwork)
### AvailableData() check avaliable data: we choose cbmc
### InstallData('pbmc3k')
library(pbmc3k.SeuratData)
### how this dataset generate?
# ## Not run:
# if (requireNamespace(Seurat, quietly = TRUE)) {
#   url <- 'http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz'
#   curl::curl_download(url = url, destfile = basename(path = url))
#   untar(tarfile = basename(path = url))
#   pbmc.data <- Seurat::Read10X(data.dir = 'filtered_gene_bc_matrices/hg19/')
#   pbmc3k <- Seurat::CreateSeuratObject(counts = pbmc.data, project = 'pbmc3k', min.cells = 3, min.features = 200)
#   # Annotations come from Seurat's PBMC3k Guided Clustering Tutorial
#   # https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html
#   annotations <- readRDS(file = system.file('extdata/annotations/annotations.Rds', package = 'pbmc3k.SeuratData'))
#   pbmc3k <- Seurat::AddMetaData(object = pbmc3k, metadata = annotations)
#   # Clean up downloaded files
#   file.remove(basename(path = url))
#   unlink(x = 'filtered_gene_bc_matrices/', recursive = TRUE)
# }
#
# ## End(Not run)
### how Create Seurat object work?
### by run `Seurat::CreateSeuratObject` you can get the source function
# ## Not run:
# Seurat::CreateSeuratObject
# function (counts, project = "SeuratProject", assay = "RNA",
#     min.cells = 0, min.features = 0, names.field = 1, names.delim = "_",
#     meta.data = NULL)
# {
#     if (!is.null(x = meta.data)) {
#         if (is.null(x = rownames(x = meta.data))) {
#             stop("Row names not set in metadata. Please ensure that rownames of metadata match column names of data matrix")
#         }
#         if (length(x = setdiff(x = rownames(x = meta.data), y = colnames(x = counts)))) {
#             warning("Some cells in meta.data not present in provided counts matrix.")
#             meta.data <- meta.data[intersect(x = rownames(x = meta.data),
#                 y = colnames(x = counts)), ]
#         }
#         if (is.data.frame(x = meta.data)) {
#             new.meta.data <- data.frame(row.names = colnames(x = counts))
#             for (ii in 1:ncol(x = meta.data)) {
#                 new.meta.data[rownames(x = meta.data), colnames(x = meta.data)[ii]] <- meta.data[,
#                   ii, drop = FALSE]
#             }
#             meta.data <- new.meta.data
#         }
#     }
#     assay.data <- CreateAssayObject(counts = counts, min.cells = min.cells,
#         min.features = min.features)
#     Key(object = assay.data) <- paste0(tolower(x = assay), "_")
#     assay.list <- list(assay.data)
#     names(x = assay.list) <- assay
#     init.meta.data <- data.frame(row.names = colnames(x = assay.list[[assay]]))
#     idents <- factor(x = unlist(x = lapply(X = colnames(x = assay.data),
#         FUN = ExtractField, field = names.field, delim = names.delim)))
#     if (any(is.na(x = idents))) {
#         warning("Input parameters result in NA values for initial cell identities. Setting all initial idents to the project name")
#     }
#     ident.levels <- length(x = unique(x = idents))
#     if (ident.levels > 100 || ident.levels == 0 || ident.levels ==
#         length(x = idents)) {
#         idents <- rep.int(x = factor(x = project), times = ncol(x = assay.data))
#     }
#     names(x = idents) <- colnames(x = assay.data)
#     object <- new(Class = "Seurat", assays = assay.list,
#         meta.data = init.meta.data, active.assay = assay, active.ident = idents,
#         project.name = project, version = packageVersion(pkg = "Seurat"))
#     object[["orig.ident"]] <- idents
#     n.calc <- CalcN(object = assay.data)
#     if (!is.null(x = n.calc)) {
#         names(x = n.calc) <- paste(names(x = n.calc), assay,
#             sep = "_")
#         object[[names(x = n.calc)]] <- n.calc
#     }
#     if (!is.null(x = meta.data)) {
#         object <- AddMetaData(object = object, metadata = meta.data)
#     }
#     return(object)
# }
#
# Seurat:: CreateAssayObject
# function (counts, data, min.cells = 0, min.features = 0)
# {
#     if (missing(x = counts) && missing(x = data)) {
#         stop("Must provide either 'counts' or 'data'")
#     }
#     else if (!missing(x = counts) && !missing(x = data)) {
#         stop("Either 'counts' or 'data' must be missing; both cannot be provided")
#     }
#     else if (!missing(x = counts)) {
#         if (anyDuplicated(rownames(x = counts))) {
#             warning("Non-unique features (rownames) present in the input matrix, making unique",
#                 call. = FALSE, immediate. = TRUE)
#             rownames(x = counts) <- make.unique(names = rownames(x = counts))
#         }
#         if (anyDuplicated(colnames(x = counts))) {
#             warning("Non-unique cell names (colnames) present in the input matrix, making unique",
#                 call. = FALSE, immediate. = TRUE)
#             colnames(x = counts) <- make.unique(names = colnames(x = counts))
#         }
#         if (is.null(x = colnames(x = counts))) {
#             stop("No cell names (colnames) names present in the input matrix")
#         }
#         if (any(rownames(x = counts) == "")) {
#             stop("Feature names of counts matrix cannot be empty",
#                 call. = FALSE)
#         }
#         if (nrow(x = counts) > 0 && is.null(x = rownames(x = counts))) {
#             stop("No feature names (rownames) names present in the input matrix")
#         }
#         if (!inherits(x = counts, what = "dgCMatrix")) {
#             counts <- as(object = as.matrix(x = counts), Class = "dgCMatrix")
#         }
#         if (min.features > 0) {
#             nfeatures <- Matrix::colSums(x = counts > 0)
#             counts <- counts[, which(x = nfeatures >= min.features)]
#         }
#         if (min.cells > 0) {
#             num.cells <- Matrix::rowSums(x = counts > 0)
#             counts <- counts[which(x = num.cells >= min.cells),
#                 ]
#         }
#         data <- counts
#     }
#     else if (!missing(x = data)) {
#         if (anyDuplicated(rownames(x = data))) {
#             warning("Non-unique features (rownames) present in the input matrix, making unique",
#                 call. = FALSE, immediate. = TRUE)
#             rownames(x = data) <- make.unique(names = rownames(x = data))
#         }
#         if (anyDuplicated(colnames(x = data))) {
#             warning("Non-unique cell names (colnames) present in the input matrix, making unique",
#                 call. = FALSE, immediate. = TRUE)
#             colnames(x = data) <- make.unique(names = colnames(x = data))
#         }
#         if (is.null(x = colnames(x = data))) {
#             stop("No cell names (colnames) names present in the input matrix")
#         }
#         if (any(rownames(x = data) == "")) {
#             stop("Feature names of data matrix cannot be empty",
#                 call. = FALSE)
#         }
#         if (nrow(x = data) > 0 && is.null(x = rownames(x = data))) {
#             stop("No feature names (rownames) names present in the input matrix")
#         }
#         if (min.cells != 0 | min.features != 0) {
#             warning("No filtering performed if passing to data rather than counts",
#                 call. = FALSE, immediate. = TRUE)
#         }
#         counts <- new(Class = "matrix")
#     }
#     if (!is.vector(x = rownames(x = counts))) {
#         rownames(x = counts) <- as.vector(x = rownames(x = counts))
#     }
#     if (!is.vector(x = colnames(x = counts))) {
#         colnames(x = counts) <- as.vector(x = colnames(x = counts))
#     }
#     if (!is.vector(x = rownames(x = data))) {
#         rownames(x = data) <- as.vector(x = rownames(x = data))
#     }
#     if (!is.vector(x = colnames(x = data))) {
#         colnames(x = data) <- as.vector(x = colnames(x = data))
#     }
#     if (any(grepl(pattern = "_", x = rownames(x = counts))) ||
#         any(grepl(pattern = "_", x = rownames(x = data)))) {
#         warning("Feature names cannot have underscores ('_'), replacing with dashes ('-')",
#             call. = FALSE, immediate. = TRUE)
#         rownames(x = counts) <- gsub(pattern = "_", replacement = "-",
#             x = rownames(x = counts))
#         rownames(x = data) <- gsub(pattern = "_", replacement = "-",
#             x = rownames(x = data))
#     }
#     if (any(grepl(pattern = "|", x = rownames(x = counts),
#         fixed = TRUE)) || any(grepl(pattern = "|", x = rownames(x = data),
#         fixed = TRUE))) {
#         warning("Feature names cannot have pipe characters ('|'), replacing with dashes ('-')",
#             call. = FALSE, immediate. = TRUE)
#         rownames(x = counts) <- gsub(pattern = "|", replacement = "-",
#             x = rownames(x = counts), fixed = TRUE)
#         rownames(x = data) <- gsub(pattern = "|", replacement = "-",
#             x = rownames(x = data), fixed = TRUE)
#     }
#     init.meta.features <- data.frame(row.names = rownames(x = data))
#     assay <- new(Class = "Assay", counts = counts, data = data,
#         scale.data = new(Class = "matrix"), meta.features = init.meta.features)
#     return(assay)
# }
###update object to avoid warning.
data("pbmc3k")
pbmc <- UpdateSeuratObject(pbmc3k)
rm(pbmc3k)
pbmc
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
### how does PercentageFeatureSet work
# PercentageFeatureSet
# function (object, pattern = NULL, features = NULL, col.name = NULL,
#     assay = NULL)
# {
#     assay <- assay %||% DefaultAssay(object = object)
#     if (!is.null(x = features) && !is.null(x = pattern)) {
#         warning("Both pattern and features provided. Pattern is being ignored.")
#     }
#     features <- features %||% grep(pattern = pattern, x = rownames(x = object[[assay]]),
#         value = TRUE)
#     percent.featureset <- colSums(x = GetAssayData(object = object,
#         assay = assay, slot = "counts")[features, , drop = FALSE])/object[[paste0("nCount_",
#         assay)]] * 100
#     if (!is.null(x = col.name)) {
#         object <- AddMetaData(object = object, metadata = percent.featureset,
#             col.name = col.name)
#         return(object)
#     }
#     return(percent.featureset)
# }
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
# Show QC metrics for the first 5 cells
head(pbmc@meta.data, 5)
# Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)
# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes,vars.to.regress = "percent.mt")
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
# Examine and visualize PCA results a few different ways
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
DimPlot(pbmc, reduction = "pca")
### 	Plot an equal number of genes with both + and - scores.
mypal <- rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdBu"))(256))
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE,fast = F)+scale_fill_gradientn(colors  = mypal)
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
ElbowPlot(pbmc)
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
pbmc <- RunTSNE(pbmc,dims = 1:10)
DimPlot(pbmc,label = T, reduction = "tsne")
test <- pbmc[["RNA_snn"]]
net <- graph.adjacency(adjmatrix = as.matrix(x = test),
mode = "undirected", weighted = TRUE,
diag = FALSE)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["tsne"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages =
# 'umap-learn')
pbmc <- RunUMAP(pbmc,umap.method = "umap-learn", dims = 1:10)
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc,label = T, reduction = "umap")
test <- pbmc[["RNA_snn"]]
net <- graph.adjacency(adjmatrix = as.matrix(x = test),
mode = "undirected", weighted = TRUE,
diag = FALSE)
plot.igraph(x = net,
layout = as.matrix(x = Embeddings(object = pbmc[["umap"]])),
edge.width = E(graph = net)$weight, vertex.label = NA,
vertex.size = 0)
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))
# you can plot raw counts as well
VlnPlot(pbmc, features = c("MS4A1", "CD79A"), slot = "counts", log = TRUE)
FeatureScatter(object = pbmc,
feature1 = "MS4A1",
feature2 = "CD79A")+
ggtitle(label = NULL)
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
"CD8A"))
top20 <- pbmc.markers %>%
group_by(cluster) %>% top_n(n = 20, wt = avg_logFC)
DoHeatmap(pbmc, features = top20$gene)
DoHeatmap(pbmc, features = top20$gene) +
scale_fill_gradientn(colors  = mypal)
top10 <- pbmc.markers %>%
group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DotPlot(object = pbmc,features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))
DotPlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))+
coord_flip()
DotPlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))+
coord_flip()
DotPlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))+
coord_flip()
RidgePlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))
RidgePlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))
RidgePlot(object = pbmc,
features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",  "CD8A"))
View(top10)
View(pbmc.markers)
View(top10)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
new.cluster.ids <- c("Naive CD4 T","CD14+ Mono", "Memory CD4 T",  "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
new.cluster.ids <- c("Naive CD4 T","CD14+ Mono", "Memory CD4 T",  "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
names(x = pbmc3k)
names(x = pbmc)
pbmc[['RNA']]
pbmc[['umap']]
names(x = pbmc)
pbmc[['RNA_nn']]
pbmc[['RNA']]
utils::methods(class = 'Seurat')
names(x = pbmc)
rna <- pbmc[['RNA']]
utils::methods(class = 'Assay')
head(x = HVFInfo(object = rna))
head(x = HVFInfo(object = rna,selection.method = "mean.var.plot"))
head(x = HVFInfo(object = rna,selection.method = "vst"))
# GetAssayData allows pulling from a specific slot rather than just data
GetAssayData(object = rna, slot = 'scale.data')[1:3, 1:3]
names(pbmc)
utils::methods(class = "DimReduc")
